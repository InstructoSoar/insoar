sp {action*apply*primitive*record*used-object*arg1
   (state <s> ^problemspace.action <act>
              ^io # Not in imagined world
              ^operator <o>
              ^topstate.verb-parameters.infer-goals true
              ^topstate.interaction.stack.segments.segment <prev-seg>)
   (<o> ^action-type primitive
        ^argument1 <obj>)
   (<prev-seg> ^purpose.type action-command
               ^info.learn-goal.used-objects <objs>)
-->
   (<objs> ^object <obj>)
}

sp {action*apply*primitive*record*used-object*arg2*argument
   (state <s> ^problemspace.action <act>
              ^io # Not in imagined world
              ^operator <o>
              ^topstate.verb-parameters.infer-goals true
              ^topstate.interaction.stack.segments.segment <prev-seg>)
   (<o> ^action-type primitive
        ^argument2.argument <obj>)
   (<prev-seg> ^purpose.type action-command
               ^info.learn-goal.used-objects <objs>)
-->
   (<objs> ^object <obj>)
}

sp {action*apply*primitive*record*used-relation*arg2*relation
   (state <s> ^problemspace.action <act>
              ^io # Not in imagined world
              ^operator <o>
              ^topstate.verb-parameters.infer-goals true
              ^topstate.interaction.stack.segments.segment <prev-seg>)
   (<o> ^action-type primitive
        ^argument2.relation <rel>)
   (<prev-seg> ^purpose.type action-command
               ^info.learn-goal.used-relations <rels>)
-->
   (<rels> ^relation <rel>)
}

sp {action*apply*primitive*record*used-action*op_name
   (state <s> ^problemspace.action <act>
              ^io # Not in imagined world
              ^operator <o>
              ^topstate.verb-parameters.infer-goals true
              ^topstate.interaction.stack.segments.segment <prev-seg>)
   (<o> ^action-type primitive
        ^name <op-name>)
   (<prev-seg> ^purpose.type action-command
               ^info.learn-goal.used-actions <actions>)
-->
   (<actions> ^action <op-name>)
}

sp {action*apply*open*record*used-predicate*open
   (state <s> ^problemspace.action <act>
              ^io
              ^operator.name op_open-location
              ^topstate.verb-parameters.infer-goals true
              ^topstate.interaction.stack.segments.segment <prev-seg>)
   (<prev-seg> ^purpose.type action-command
               ^info.learn-goal.used-predicates <preds>)
-->
   (<preds> ^predicate door)
}
   
sp {action*apply*close*record*used-predicate*closed
   (state <s> ^problemspace.action <act>
              ^io
              ^operator.name op_close-location
              ^topstate.verb-parameters.infer-goals true
              ^topstate.interaction.stack.segments.segment <prev-seg>)
   (<prev-seg> ^purpose.type action-command
               ^info.learn-goal.used-predicates <preds>)
-->
   (<preds> ^predicate door)
}
   
sp {action*apply*activate*record*used-predicate*on
   (state <s> ^problemspace.action <act>
              ^io
              ^operator.name op_activate
              ^topstate.verb-parameters.infer-goals true
              ^topstate.interaction.stack.segments.segment <prev-seg>)
   (<prev-seg> ^purpose.type action-command
               ^info.learn-goal.used-predicates <preds>)
-->
   (<preds> ^predicate heat)
}
   
sp {action*apply*stop*record*used-predicate*off
   (state <s> ^problemspace.action <act>
              ^io
              ^operator.name op_stop
              ^topstate.verb-parameters.infer-goals true
              ^topstate.interaction.stack.segments.segment <prev-seg>)
   (<prev-seg> ^purpose.type action-command
               ^info.learn-goal.used-predicates <preds>)
-->
   (<preds> ^predicate heat)
}

sp {action*apply*wait*record*used-predicate*cooked
   (state <s> ^problemspace.action <act>
              ^io
              ^operator.name op_wait
              ^topstate.verb-parameters.infer-goals true
              ^topstate.interaction.stack.segments.segment <prev-seg>)
   (<prev-seg> ^purpose.type action-command
               ^info.learn-goal.used-predicates <preds>)
-->
   (<preds> ^predicate cooked)
}
   
   

